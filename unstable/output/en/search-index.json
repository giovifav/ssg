[
  {
    "title": "My Experimental Projects",
    "url": "index.html",
    "date": "2025-01-01",
    "content": "Hello, I'm Giovanni Favaro. Welcome! This is my digital workshop, where I collect and share my software creations. As a hobbyist programmer, I'm driven by curiosity and a passion for building, which has led me to explore a diverse range of projects—from developer tools to retro-style games. I've just released my latest project, Whisperli , an ambient sound mixer built to help you find your perfect soundscape for work or relaxation. × ‹ ›"
  },
  {
    "title": "Gio's static site generator",
    "url": "gssg/index.html",
    "date": "2025-09-17",
    "content": "Gio's Static Site Generator A modern and intuitive static site generator written in Python with a Textual-based terminal interface. Description This tool allows you to create static websites starting from Markdown files. It offers a simple graphical interface to manage content, apply themes, and generate sites ready for publication. Supports image galleries, blog systems, automatic navigation, and much more. Download Main Features Markdown Processing : Converts Markdown files into HTML pages using frontmatter for metadata. Customizable Themes : Flexible templates with Jinja2 to customize the site's appearance. Automatic Galleries : Creates image galleries with thumbnails and integrated viewer. Blog Systems : Organizes content into articles with chronological sorting. User Interface : Modern TUI to manage sites without complex commands. Automatic Navigation : Sidebar and breadcrumbs generated automatically. Multilingual : Support for Italian and English. System Requirements Python 3.8 or higher Dependencies listed in requirements.txt Installation git clone https://github.com/giovifav/ssg.git cd ssg # Create virtual environment python -m venv .venv .venv\\Scripts\\activate # Windows # source .venv/bin/activate # macOS/Linux # Install dependencies pip install -r requirements.txt # Launch the application python main.py Usage Launch the application with python main.py . Basic Steps Initialize a new site : Choose a folder and configure name and author. Add content : Create .md files in the content/ folder with frontmatter for title, date, author. Add images and assets : Place static files in the assets/ folder. Generate the site : The application automatically creates HTML output in the configured directory. Basic Structure of a Site my-site/ ├── content/ │ └── index.md ├── assets/ │ ├── theme.html │ └── theme.css └── config.toml License This project is open source under MIT license. For support or issues, visit the GitHub repository . × ‹ ›"
  },
  {
    "title": "Piece by piece puzzle",
    "url": "jigsaw/index.html",
    "date": "2025-09-17",
    "content": "A relaxing puzzle game where you reassemble images into complete pictures. Game Overview Play with real-world images in categories: animals, landscapes, architecture, and people. Select difficulty levels from easy (3x3 pieces) to hard (8x8 pieces) and assemble the puzzle. Download How to Play Choose an image from the menu. Select difficulty. Move pieces with mouse/touch, use zoom. Complete the puzzle and view your time/moves. Resume saved games or try hardcore mode. Features Categorized images Difficulty levels: 3x3 to 8x8 Hardcore mode (no hints) Save/Resume games Leaderboard Sound &amp; Music controls Italian/English language Custom image support Touch/Mouse friendly Requirements 1024x768 resolution or higher Installation Download game files. Install Love2D from official site. Run game via Love2D. Credits Images: Pexels Music: CC licensed tracks by various artists Framework: Love2D Font: Caviar Dreams Full credits in credits.txt License Images and music: Creative Commons × ‹ ›"
  },
  {
    "title": "LuaPyDoc",
    "url": "luapydoc/index.html",
    "date": "2025-01-01",
    "content": "Luapydoc is a Python-based documentation generator for Lua codebases. It analyzes LDoc-style documentation comments in Lua source files and generates a complete, navigable HTML documentation website with syntax highlighting, search functionality, and more. Repository Sample output Features Analyzes LDoc documentation comments (@param, @return, @usage, etc.) Supports functions, variables, tables, and types Generates responsive HTML pages with dark theme Syntax highlighting for Lua code using Pygments Tree-based sidebar navigation for modules, classes, and functions Full-text search with indexing Responsive design for mobile and desktop Requirements Python 3.x jinja2 pygments Installation Clone this repository. Install dependencies: pip install -r requirements.txt Usage Place your Lua source files in a directory (e.g. lua_src ), organized in subdirectories if necessary. Run the generator with desired options (see examples below). Open the index.html file in the output directory in your browser to view the documentation. Command Line Options # Basic usage with default directories python docs_generator.py # Specify custom source and output directories python docs_generator.py --src-dir ./my_lua_code --output-dir ./my_docs # Using short forms python docs_generator.py -s ./src -o ./docs # Specify only source directory (default output 'docs') python docs_generator.py --src-dir ./lua_src Available parameters: - -s, --src-dir : Directory containing Lua source files (default: lua_src ) - -o, --output-dir : Directory to generate documentation (default: docs ) Full help: python docs_generator.py --help Project Structure docs_generator.py : Main script that analyzes Lua files and generates documentation docs_template.html : Jinja2 template for HTML pages docs_style.css : CSS styles for the documentation website requirements.txt : Python dependencies lua_src/ : Directory for Lua source files (create it) docs/ : Output directory for generated HTML files How It Works The generator works in two phases: 1. Parses documentation comments (e.g. --- @param name desc) 2. Associates them with function definitions or variable assignments 3. Builds a hierarchical tree for navigation 4. Generates HTML pages using Jinja2 templates 5. Includes Lua code with syntax highlighting Customization You can customize the appearance by modifying docs_style.css and the layout by modifying docs_template.html ."
  },
  {
    "title": "Navigate and loot",
    "url": "Nal/index.html",
    "date": "2025-09-17",
    "content": "A little pirate game. Sail, plunder, survive! Made for gdevelop 3d jam. https://minifun.itch.io/navigate-and-lootjam Instructions: Sail with wasd, throw cannonballs with arrow keys, fish with space to boost your crew's morale and go faster. loot the loot near your ship with space. Information: In the jam version a bug does not allow you to die and on some mobile devices there may be problems with resolution. Being my first game with gdevelop I am quite happy with the result. × ‹ ›"
  },
  {
    "title": "Play64 Docs",
    "url": "play64/documentation.html",
    "date": "2025-09-17",
    "content": "Play64 is a fantasy console developed for The Tool Jam 2025. It features a D-pad and two action buttons, with a display capable of rendering four shades of violet. Games are written in Lua 5.1. The console itself is implemented using BlitzMax NG and the Raylib graphics library. https://github.com/user-attachments/assets/d3407e81-d0d5-4821-9e4d-ee68e37a5cda Controls The up button is mapped to the UP and W keys The down button is mapped to the DOWN and S keys The left button is mapped to the LEFT and A keys The right button is mapped to the RIGHT and D keys The A button is mapped to the Z and N keys The B button is mapped to the X and M keys Press ESC to close the application window Press R to reset the console Press F to toggle fullscreen mode Press P to pause the game How to release your game To prepare your game for release, edit the config.ini file: set Game to your game's internal name, Title to the window title, and Intro to False . Remove any unused files from the carts directory. You may then rename the play64.exe executable as desired. \"config.ini\" file [Settings] ; This is the configuration file for the Play64 fantasy console ; It contains settings for the console Fullscreen=False ; Set to True for fullscreen mode ; Set to False for windowed mode Width=800 ; Width of the window in pixels Height=600 ; Height of the window in pixels Intro=True ; Set to True to show the intro screen ; Set to False to skip the intro screen Game= ; The name of the game to load ; Leave empty to load the selection screen Title=Play64 fantasy console ; This is the title of the window ; It will be displayed in the title bar ; The title of the window can be changed in the code input The object module offer an interface to the input system input.down() Return a string with the key that is pressed print(input.down()) -- print up or down or left or right or a or b input.pressed() Return a string with the key that has been pressed print(input.pressed()) -- print up or down or left or right or a or b input.released() Return a string with the key that has been released print(input.released()) -- print up or down or left or right or a or b draw The object module offer an interface to the drawing commands colors palette 4 color palette 0 = darkest, 3 = brightest draw.background(color:Int) Change the color of background 0 = darkest, 3 = brightest draw.background(0) draw.color(color:Int) set the color of the draw command 0 = darkest, 3 = brightest draw.color(3) draw.point(x:Int, y:int ) Draw a pixel --draw a point draw.point(32,18) draw.line(startx:Int, startY:Int, endX:Int, endY:Int) Draw a line --draw a line draw.line(0,0,18,36) draw.rect(x:Int, y:Int, Width:Int, height:Int) Draw a rectangle --draw a rectangle draw.rect(0,0,20,20) draw.text(text:String, x:Int, y:Int, size:Int) Print a string of text Minimum size = 10 draw.text(&quot;a string of text&quot;,0,0,15) draw.circle(x:Int, y:Int, Radius:Int) Draw a circle --draw a circle draw.rect(30,30,10) draw.triangle(x1:Int, y1:Int, x2:Int, y2:Int, x3:Int, y3:Int) Draw a triangle --draw a triangle draw.triangle(1,1,63,1,32,63) draw.sprite(title:String, x:Int, y:Int) draw.sprite(&quot;enemy&quot;, 10,10) -- same as sprites.draw(&quot;enemy&quot;,10,10) app The object module offer an interface for manage all the app settings app.dt() Return the delta time in seconds The default game target fps is 30 frame per second. app.title(title:String) set the title of the window app.width(width:Int) set the width of the window app.height(heigth:Int) set the height of the window app.fullscreen() toggle the fullscreen mode app.reset() reset the cart and go back to selection screen app.restart() restart the current cart app.loadCart(cart:String) load a specific cart app.loadCart(&quot;snake&quot;) app.save(key:String, value:String) save a value of the current game app.save(&quot;highscore&quot;, &quot;1000&quot;) app.load(key:String, value:String) load a value of the current game app.load(&quot;highscore&quot;) Sound The object module offer an interface to sound system sound.play(sound:String) play a built-in sound by name --play bump sound effect sound.play(&quot;bump&quot;) Possible values: bottle_break, bump, cancel, cat_meow, click, confirm, crunch, digital_alarm, dog_bark, door_slow_open, drink, evil_laugh, explosion, gun, hurt, jump, laser_gun, low_health, menu_in, menu_out, monster_scream, notso_confirm, pause, phone_ring, powerdown, powerup, siren, steps, sword_slash, thunder, trampoline, water_splash, Camera The object module offer an interface to the camera system camera.target(x:Int, y:Int) --set position of the camera at 10, 10 camera.target(10,10) camera.offset(x:Int, y:Int) --set offset of the camera at 10, 10 camera.offset(10,10) camera.rotation(deg:Float) --set rotation of the camera at 45 camera.target(45.0) camera.zoom(zoom:Float) --set zoom of the camera at 1.2 camera.target(1.2) camera.reset() --reset the camera camera.reset() Sprites sprites.add(title:String, data:String) Return title:String local enemySprite = [[ 0 0 0 0 0 0 0 0 0 0 0 1 1 1 1 1 1 1 1 0 0 1 0 0 0 0 0 0 1 0 0 1 0 1 1 1 1 0 1 0 0 1 0 1 0 0 1 0 1 0 0 1 0 1 1 1 1 0 1 0 ]] sprite = sprites.add(&quot;enemy&quot;, enemySprite) -- sprite == &quot;enemy&quot; sprites.draw(title:String, x:Int, y:Int) sprites.draw(&quot;enemy&quot;,10,10) -- same as draw.sprite(&quot;enemy&quot;, 10,10) sprites.collision(sprite1:String, x1:Int, y1:Int, sprite2:String, x2:Int, y2:Int) Return 1 in case of collision if sprites.collision(&quot;player&quot;,player.x,player.y,&quot;enemy&quot;,enemy.x,enemy.Y) == 1 then --Collision! Do something end Timer The object module offer an interface for manage timers timer.delay(fn, delay) Calls the function fn after the given delay time has passed. Returns the associated event. -- Prints &quot;Hello world!&quot; after 2 seconds timer.delay(function() print(&quot;Hello world!&quot;) end, 2) timer.recur(fn, delay) Calls the function fn at an interval of delay . Returns the associated event. -- Prints timer!&quot; every half-second timer.recur(function() print( timer!&quot;) end, .5) Chaining events To avoid having to deeply nest several functions when creating chains of events, the :after() method can be called on an event returned by timer.delay() . You can keep using the :after() method to create complex timed sequences. -- Prints &quot;cat&quot;, &quot;dog&quot;, then &quot;owl&quot;, waiting 1 second between each print timer.delay(function() print(&quot;cat&quot;) end, 1) :after(function() print(&quot;dog&quot;) end, 1) :after(function() print(&quot;owl&quot;) end, 1) Stopping events An event can be stopped and removed at any point by calling its :stop() method. To do this the event must be assigned to a variable when it is created. -- Create a new event local t = timer.delay(function() print( timer!&quot;) end, 10) -- Remove the event before it has a chance to run t:stop() Groups timer provides the ability to create event groups; these are objects which can have events added to them, and which are in charge of updating and handling their contained events. A group is created by calling the timer.group()` function. local group = timer.group() Once a group is created it acts independently of the timer` object, and must be updated each frame using its own update method. group:update() To add a events to a group, the group's :delay() or :recur() methods should be used. group:delay(function() print(&quot;hello world&quot;) end, 4) A good example of where groups are useful is for games where you may have a set of events which effect objects in the game world and which you want to pause when the game is paused. A group's events can be paused by simply neglecting to call its update() method; when a group is destroyed its events are also destroyed. object The object module offer an interface for OOP programming Creating a new class Point = object:extend() function Point:new(x, y) self.x = x or 0 self.y = y or 0 end Creating a new object local p = Point(10, 20) Extending an existing class Rect = Point:extend() function Rect:new(x, y, width, height) Rect.super.new(self, x, y) self.width = width or 0 self.height = height or 0 end Checking an object's type local p = Point(10, 20) print(p:is(Object)) -- true print(p:is(Point)) -- true print(p:is(Rect)) -- false Using mixins PairPrinter = object:extend() function PairPrinter:printPairs() for k, v in pairs(self) do print(k, v) end end Point = object:extend() Point:implement(PairPrinter) function Point:new(x, y) self.x = x or 0 self.y = y or 0 end local p = Point() p:printPairs() Using static variables Point = object:extend() Point.scale = 2 function Point:new(x, y) self.x = x or 0 self.y = y or 0 end function Point:getScaled() return self.x * Point.scale, self.y * Point.scale end Creating a metamethod function Point:__tostring() return self.x .. &quot;, &quot; .. self.y end Tween The object module offer an interface for tweening Tween creation local t = tween.new(duration, subject, target, [easing]) Creates a new tween. duration means how much the change will take until it's finished. It must be a positive number. subject must be a table with at least one key-value. Its values will be gradually changed by the tween until they look like target . All the values must be numbers, or tables with numbers. target must be a table with at least the same keys as subject . Other keys will be ignored. easing can be either a function or a function name (see the easing section below). It's default value is 'linear' t is the object that must be used to perform the changes - see the \"Tween methods\" section below. This function only creates and returns the tween. It must be captured in a variable and updated via t:update(dt) in order for the changes to take place. Tween methods local complete = t:update() Gradually changes the contents of subject to that it looks more like target as time passes. t is a tween returned by tween.new complete is true if the tween has reached its limit (its internal clock is &gt;= duration ). It is false otherwise. When the tween is complete, the values in subject will be equal to target 's. The way they change over time will depend on the chosen easing function. local complete = t:set(clock) Moves a tween's internal clock to a particular moment. t is a tween returned by tween.new clock is a positive number or 0. It's the new value of the tween's internal clock. complete works like in t:update ; it's true if the tween has reached its end, and false otherwise. If clock is greater than t.duration , then the values in t.subject will be equal to t.target , and t.clock will be equal to t.duration . t:reset() Resets the internal clock of the tween back to 0, resetting subject . t is a tween returned by tween.new This method is equivalent to t:set(0) . Easing functions Easing functions are functions that express how slow/fast the interpolation happens in tween. The easing functions can be found in the table tween.easing . They can be divided into several families: linear is the default interpolation. It's the simplest easing function. quad , cubic , quart , quint , expo , sine and circle are all \"smooth\" curves that will make transitions look natural. The back family starts by moving the interpolation slightly \"backwards\" before moving it forward. The bounce family simulates the motion of an object bouncing. The elastic family simulates inertia in the easing, like an elastic gum. Each family (except linear ) has 4 variants: in starts slow, and accelerates at the end out starts fast, and decelerates at the end inOut starts and ends slow, but it's fast in the middle outIn starts and ends fast, but it's slow in the middle family in out inOut outIn Linear linear linear linear linear Quad inQuad outQuad inOutQuad outInQuad Cubic inCubic outCubic inOutCubic outInCubic Quart inQuart outQuart inOutQuart outInQuart Quint inQuint outQuint inOutQuint outInQuint Expo inExpo outExpo inOutExpo outInExpo Sine inSine outSine inOutSine outInSine Circ inCirc outCirc inOutCirc outInCirc Back inBack outBack inOutBack outInBack Bounce inBounce outBounce inOutBounce outInBounce Elastic inElastic outElastic inOutElastic outInElastic When you specify an easing function, you can either give the function name as a string. The following two are equivalent: local t1 = tween.new(10, subject, {x=10}, tween.easing.linear) local t2 = tween.new(10, subject, {x=10}, 'linear') But since 'linear' is the default, you can also do this: local t3 = tween.new(10, subject, {x=10}) Custom easing functions You are not limited to tween's easing functions; if you pass a function parameter in the easing, it will be used. The passed function will need to take 4 parameters: t (time): starts in 0 and usually moves towards duration b (begin): initial value of the of the property being eased. c (change): ending value of the property - starting value of the property d (duration): total duration of the tween And must return the new value after the interpolation occurs. local cubicbezier = function (x1, y1, x2, y2) local curve = love.math.newBezierCurve(0, 0, x1, y1, x2, y2, 1, 1) return function (t, b, c, d) return c * curve:evaluate(t/d) + b end end local label = { x=200, y=0, text = &quot;hello&quot; } local labelTween = tween.new(4, label, {y=300}, cubicbezier(.35, .97, .58, .61)) Credits Engine written in BlitzMax NG Carts written in Lua 5.1 The graphic library is Raylib Classic by rxi for lua OOP Tween by kikito Tick by rxi Sound Effects by Coffee 'Valen' Bat"
  },
  {
    "title": "Play64 fantasy console",
    "url": "play64/index.html",
    "date": "2025-09-17",
    "content": "Play64 is a fantasy console developed for The Tool Jam 5. It Is a game engine for Gameboy/Atari 2600 games It features a D-pad and two actiown buttons, with a 64 x 64 display capable of rendering four shades of violet. Games are written in Lua 5.1. The console itself is implemented using BlitzMax NG and the Raylib graphics library. Controls The up button is mapped to the UP and W keys The down button is mapped to the DOWN and S keys The left button is mapped to the LEFT and A keys The right button is mapped to the RIGHT and D keys The A button is mapped to the Z and N keys The B button is mapped to the X and M keys Press ESC to close the application window Press R to reset the console Press F to toggle fullscreen mode Press P to pause the game × ‹ › Name Size Date Download docs.pdf 137.8 KB 2025-05-14 13:19 Download play64.zip 1.7 MB 2025-05-14 13:22 Download"
  },
  {
    "title": "VectorDefense",
    "url": "VectorDefense/index.html",
    "date": "2025-01-01",
    "content": "VectorDefense VectorDefense is a tower defense game built with LÖVE in Lua. It features grid-based maps where players defend against waves of enemies using towers. The game utilizes a modular architecture for enemies, towers, puzzles, and more. Note: This project is still in early development and is not fully implemented. Requirements LÖVE 2D game engine (version 11.3 or compatible) How to Run Install LÖVE from love2d.org . Clone or download this repository. Navigate to the project directory. Run love.exe . (Windows) or love . (Linux/Mac). Project Structure src/ : Game logic modules (enemies, towers, maps, etc.) libs/ : External libraries (camera, event, etc.) mod/ : Music and assets × ‹ ›"
  },
  {
    "title": "Voxel64",
    "url": "voxel64/index.html",
    "date": "2025-01-01",
    "content": "A simple voxel space renderer for Love2D, simulating 3D terrain flight using heightmaps. repository Based on s-macke/VoxelSpace Features Procedural terrain rendering based on height and color maps Flight controls for navigation Multiple terrain maps included Basic HUD display Requirements Love2D game engine Running Run the game with: love /path/to/voxel64-master Controls W/A/S/D: Move forward/left/back/right Arrow up/down: Increase/decrease height Numbers 1-5: Switch maps H: Toggle HUD Esc: Quit × ‹ ›"
  },
  {
    "title": "Whisperli",
    "url": "whisperli_info/index.html",
    "date": "2025-01-01",
    "content": "Whisperli is a simple web-based ambient sound mixer application that allows you to create custom audio mixes by combining different sounds. Features Browse sounds organized by categories Add sounds to the mixer interface Play and stop audio mixes Save and load audio mixes Select from a variety of background images Toggle between light and dark themes Search functionality for sounds Technologies HTML CSS JavaScript (ES6 Modules) Repository The source code is available at https://github.com/giovifav/whisperli"
  }
]