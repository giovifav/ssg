[
  {
    "title": "Downloadable Files",
    "url": "play64/_files/index.html",
    "date": null,
    "content": "Name Size Date Download docs.pdf 137.8 KB 2025-05-14 13:19 Download play64.zip 1.7 MB 2025-05-14 13:22 Download"
  },
  {
    "title": "Gio's unstable code",
    "url": "index.html",
    "date": "2025-01-01",
    "content": "Welcome This is your new site. Edit content/index.md to get started."
  },
  {
    "title": "Gio's static site generator",
    "url": "gssg/index.html",
    "date": "2025-09-17",
    "content": "Gio's Static Site Generator Un generatore di siti statici moderno e potente scritto in Python con interfaccia terminale basata su Textual. Descrizione Questo progetto permette di creare e gestire siti web statici utilizzando contenuto Markdown. Fornisce sia un'interfaccia a riga di comando che un'interfaccia utente grafica intuitiva per inizializzare nuovi siti, modificare contenuti e generare output HTML. Il generatore supporta temi, frontmatter, alberi di navigazione, breadcrumbs, gestione assets, gallerie di immagini e sistemi blog avanzati. Caratteristiche Principali Generazione Sito Inizializzazione Sito : Creazione rapida di progetti sito con struttura predefinita Processamento Markdown : Conversione da Markdown a HTML con supporto frontmatter (titolo, data, autore) Template Engine : Usa Jinja2 per templating flessibile con temi personalizzabili Navigazione : Generazione automatica sidebar navigazione e breadcrumbs Gestione Assets : Copia asset statici nella directory di output Indice di Ricerca : Generazione indice JSON per funzionalità di ricerca integrata Gallery e Media Generazione Galleria : Creazione automatica di gallerie da directory _gallery/ Thumbnails : Generazione automatica thumbnails con supporto EXIF Modal Viewer : Visualizzatore immagini modal integrato Lazy Loading : Caricamento immagini ottimizzato in base alla visibilità Sistemi Blog Organizzazione Blog : Supporto cartelle _blog/ con processamento dedicato Frontmatter Avanzato : Metadata estese per post (autore, categorie, tags) Ordinamento : Ordinamento cronologico automatico dei post Template Dedicati : Layout specifici per pagine blog Interfaccia Utente TUI Moderna : Interfaccia terminale ricca basata su Textual Editor Integrato : Modifica diretta di file Markdown e altri contenuti Preview Live : Anteprima generazione sito in tempo reale Themes UI : Molteplici temi (gruvbox, nord, tokyo-night, etc.) Internazionalizzazione : Supporto italiano e inglese Strumenti Gestione : Creazione gallerie, blog, pagine automaticamente Sicurezza e Performance Pulizia Path : Validazione percorsi file per evitare traversal Gestione Memoria : Processing efficiente per siti grandi Fallback Sicuri : Comportamenti sicuri in caso di errori Ottimizzazioni : Caching, lazy loading e ottimizzazioni varie Requisiti di Sistema Python 3.8 o superiore Dipendenze installate automaticamente via requirements.txt : textual[syntax] : Per l'interfaccia terminale python-frontmatter : Per parsing frontmatter Markdown markdown : Per conversione Markdown → HTML con estensioni avanzate jinja2 : Per rendering template toml : Per gestione file configurazione Pillow : Per processamento immagini galleire (opzionale) Installazione Setup Automatico (Raccomandato) # Clona o scarica il repository git clone https://github.com/tuo-user/ssg.git cd ssg # Avvia il setup automatico python run.py Lo script run.py eseguirà: - Creazione ambiente virtuale (se non esistente) - Installazione/aggiornamento dipendenze Python - Lancio applicazione Setup Manuale # Crea ambiente virtuale python -m venv .venv # Attiva l'ambiente virtuale # Windows: .venv\\Scripts\\activate # macOS/Linux: source .venv/bin/activate # Installa dipendenze pip install -r requirements.txt # Avvia l'applicazione python main.py Utilizzo Avvio Applicazione Usa python run.py per setup automatico o python main.py per avviamento manuale. Menu Principale L'applicazione presenta tre opzioni principali: Inizializza Nuovo Sito - Scegli directory base - Inserisci nome cartella sito - Imposta nome sito e autore - Creazione struttura base automatica Apri Sito Esistente - Sfoglia e seleziona directory progetto esistente - Accesso a strumenti modifica e generazione Impostazioni - Cambia tema interfaccia - Cambia lingua (Italiano/Inglese) Creazione Contenuto I progetti sito hanno questa struttura: mio-sito/ ├── content/ # File Markdown qui ├── assets/ # File statici (immagini, CSS, etc.) ├── config.toml # Configurazione sito ├── assets/theme.html # Template principale └── assets/theme.css # CSS sito File Markdown Base Crea file .md nella cartella content/ usando frontmatter: --- title: &quot;Il Mio Titolo Pagina&quot; date: &quot;2024-01-01&quot; author: &quot;Nome Autore&quot; --- # Intestazione Principale Il tuo contenuto qui... Supporta **Markdown** completo con: - Liste ordinate e non ordinate - [Link](https://esempio.com) - `Codice inline` e blocchi codice ```python # Esempio blocco codice print(&quot;Hello, World!&quot;) #### Creazione Galleria Crea una directory `_gallery/` dentro `content/` e aggiungi immagini: content/ ├── index.md └── foto/ ├── index.md # Pagina galleria └── _gallery/ # Immagini galleria ├── vacanza1.jpg ├── vacanza2.jpg └── ... Il generatore creerà automaticamente: - Pagina galleria HTML - Thumbnails ottimizzati - Modal viewer per visualizzazione ingrandita #### Sistem Blog Organizza contenuti blog in cartelle `_blog/`: content/ ├── index.md └── articoli/ ├── index.md # Pagina blog principale └── _blog/ # Post articoli ├── primo-post.md ├── secondo-articolo.md └── ... I post possono includere metadata avanzate: ```markdown --- title: &quot;Il Mio Primo Articolo&quot; date: &quot;2024-12-25&quot; author: &quot;Mario Rossi&quot; summary: &quot;Riassunto dell'articolo per anteprima&quot; tags: [&quot;tecnologia&quot;, &quot;python&quot;] draft: false --- Generazione Sito Dalla schermata editor sito: 1. Seleziona \"Genera Sito\" 2. Il generatore eseguirà: - Parsing tutti i file Markdown in content/ - Applicazione template per creare HTML - Costruzione navigazione e breadcrumbs - Copia assets statici - Generazione indice ricerca JSON - Output nella directory configurata Il processo è completamente statico, privo di dipendenze lato server. Struttura Progetto . ├── assets/ # Template e risorse predefinite │ ├── theme.html # Template principale sito │ ├── theme.css # CSS principale sito │ ├── gallery.html # Template gallerie │ ├── gallery.css # CSS gallerie │ ├── blog.html # Template pagine blog │ └── 404.html # Template errore 404 ├── ui/ # Componenti interfaccia Textual │ ├── app.py # Applicazione principale TUI │ ├── editor.py # Editor file integrato │ ├── menu.py # Menu di navigazione │ └── ... # Altri componenti UI ├── languages/ # File traduzione interfaccia │ ├── en.json # Traduzioni inglese │ └── it.json # Traduzioni italiano ├── test_site/ # Sito esempio funzionante ├── unstable/ # Versione di sviluppo con esempio galleria ├── BUGS_IMPROVEMENTS.md # Report completo bug e migliorie ├── site_generator.py # Motore generazione core ├── nav_builder.py # Costruttore navigazione ├── config.py # Gestione configurazione sito ├── config_manager.py # Gestione configurazione UI ├── main.py # Entry point applicazione └── run.py # Script setup automatico Configurazione Configurazione Sito (config.toml) Localizzato in ogni root directory sito: # Configurazione base site_name = &quot;Il Mio Sito&quot; author = &quot;Nome Autore&quot; footer = &quot;© 2024 Tutti i diritti riservati&quot; # Directory e temi output = &quot;output&quot; base_theme = &quot;assets/theme.html&quot; theme_css = &quot;assets/theme.css&quot; # Opzioni avanzate (futuro) # theme_js = &quot;assets/theme.js&quot; # gallery_template = &quot;assets/gallery.html&quot; # blog_template = &quot;assets/blog.html&quot; Configurazione UI Impostazioni salvate in config.json nella directory script: - Lingua preferita dell'interfaccia - Tema interfaccia selezionato - Ultime directory utilizzate API Core Funzioni Principali site_generator.generate_site(site_root: Path, log: UILog = None) Genera sito statico dalla directory progetto. - Parametri: - site_root : Path alla root del progetto sito - log : Logger opzionale per output progresso - Risultato: Sito HTML completo nella directory output/ nav_builder.build_nav_tree(content_root: Path, output_root: Path) Costruisce albero navigazione da struttura content. - Parametri: - content_root : Directory content/ del sito - output_root : Directory output per calcolo percorsi - Risultato: Oggetto NavNode root con gerarchia completa config.read_config(site_root: Path) Legge configurazione TOML del sito. - Parametri: - site_root : Root directory progetto sito - Risultato: Oggetto SiteConfig con configurazione valida Esempi Avanzati Workflow Completo # 1. Setup progetto python run.py # 2. Creazione nuovo sito # Nel TUI: Initialize New Site → Inserisci dettagli # 3. Aggiunta contenuti echo '--- title: &quot;Benvenuto&quot; date: &quot;2024-12-25&quot; --- # Benvenuto nel Mio Sito Questo è un esempio di pagina MD.' &gt; mio-sito/content/index.md # 4. Aggiunta galleria mkdir -p mio-sito/content/foto/_gallery cp immagini/*.jpg mio-sito/content/foto/_gallery/ echo '--- title: &quot;Le Mie Foto&quot; --- # Galleria Personale Le mie foto preferite.' &gt; mio-sito/content/foto/index.md # 5. Generazione sito # Nel TUI: Apri sito → Genera Sito Template Personalizzato Modifica mio-sito/assets/theme.html : &lt;!DOCTYPE html&gt; &lt;html lang=&quot;it&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;{{ page_title }} - {{ site_name }}&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;{{ theme_css_url }}&quot;&gt; &lt;!-- Aggiungi meta tag personalizzati --&gt; &lt;meta name=&quot;description&quot; content=&quot;Il mio sito personale&quot;&gt; &lt;/head&gt; &lt;body&gt; &lt;header&gt; &lt;h1&gt;{{ site_name }}&lt;/h1&gt; &lt;nav&gt;{{ sidebar_html | safe }}&lt;/nav&gt; &lt;/header&gt; &lt;main&gt; &lt;div class=&quot;breadcrumbs&quot;&gt;{{ breadcrumbs | safe }}&lt;/div&gt; &lt;h1&gt;{{ page_title }}&lt;/h1&gt; &lt;div class=&quot;content markdown-body&quot;&gt; {{ content_html | safe }} &lt;/div&gt; &lt;/main&gt; &lt;footer&gt;{{ footer }}&lt;/footer&gt; &lt;script src=&quot;{{ common_js_url }}&quot;&gt;&lt;/script&gt; &lt;/body&gt; &lt;/html&gt; Risoluzione Problemi Problemi Comuni Errore \"No TOML reader available\" Sintomo: Errore parsing config.toml Soluzione: # Installa libreria TOML mancante pip install toml # Oppure aggiorna a Python 3.11+ per tomllib built-in Galleria non appare Sintomo: Immagini non visualizzate nella pagina galleria Soluzioni: - Verifica directory _gallery/ con immagini .jpg/.png/.webp - Controlla permessi file lettura - Installa Pillow: pip install Pillow - Verifica generazione thumbnails in _thumbs/ Template non trovato Sintomo: Errore \"Theme not found\" Soluzioni: - Verifica esistenza file in config.toml - Copia template da assets/ del repository - Controlla percorsi relativi corretti Debug Avanzato Abilita logging dettagliato nel codice: import logging logging.basicConfig(level=logging.DEBUG) Verifica generazione con output verboso: # In site_generator.py if log: log.write(f&quot;[DEBUG] Processing: {md_file}&quot;) Performance Per siti grandi (&gt;1000 pagine): - Considera riduzione dimensione gallerie (&lt;500 immagini ciascuna) - Aumenta memoria RAM disponibile - Usa SSD per storage temporaneo - Monitora generazione con strumenti profiling Sviluppo e Contributi Setup Ambiente Sviluppo # Fork e clone repository git clone https://github.com/tuo-username/ssg.git cd ssg # Crea branch feature git checkout -b feature/nome-feature # Installa dipendenze sviluppo pip install -r requirements.txt pip install pytest black mypy # Per testing e linting # Esegui tests pytest # Controllo qualità codice black . mypy . Contributi Welcome Aggiunta nuove funzionalità template Migliorie UX interfaccia Ottimizzazioni performance Fix di sicurezza Documentazione aggiuntiva Test Cases I test coprono attualmente: - Generazione sito base - Parsing frontmatter - Costruzione navigazione - Configurazione valida/invalida Aggiungere test per: - Sistema gallerie - Sistema blog - Gestione errori - Sicurezza input Deployment e Hosting Il progetto genera siti completamente statici, distribuibili su: GitHub Pages # Configura per pubblicazione echo &quot;output/&quot; &gt;&gt; .gitignore # Non committare output generato # Build automatico in GitHub Actions # Aggiungi .github/workflows/deploy.yml Altri Provider Netlify : Drag &amp; drop directory output/ Vercel : Integrazione Git automatica Surge : npx surge output/ Servizi tradizionali : Upload via FTP/S3 CDN e Performance Abilita compressione GZip sui server Configura cache headers Usa CDN (Cloudflare, Fastly) per assets statici Valuta prerendering per ulteriori ottimizzazioni Licenza Questo progetto è open source sotto licenza MIT. Vedere il file LICENSE per dettagli completi. Ringraziamenti Textual per il framework TUI Jinja2 per il template engine Python-Markdown per la conversione MD→HTML Pillow per processamento immagini Per ulteriore supporto o segnalazione bug, visitare il repository GitHub ."
  },
  {
    "title": "Piece by piece puzzle",
    "url": "jigsaw/index.html",
    "date": "2025-09-17",
    "content": "Jigsaw Puzzle Questo è un gioco di puzzle dove devi ricomporre immagini dividendo in pezzi e assemblandoli nel posto giusto. Cosa è il gioco Jigsaw Puzzle è un gioco dove puoi giocare con immagini del mondo reale divise in categorie come animali, luoghi naturali, edifici e persone. Devi prendere i pezzi sparsi e metterli insieme per formare l'immagine completa. È un modo semplice per passare il tempo e rilassarsi. Come giocare Apri il gioco dal menu iniziale. Scegli una immagine dalla lista disponibile. Seleziona la difficoltà, che va da facile con pochi pezzi a molto difficile con molti pezzi. Inizia a muovere i pezzi con il mouse. Quando hai finito di ricomporre l'immagine, il gioco ti dice che hai vinto e registra il tuo tempo e i tuoi movimenti. Puoi rivedere le tue prestazioni nella classifica o giocare di nuovo. Puoi salvare la tua partita a metà e continuare dopo. Se vuoi una sfida extra, prova la modalità hardcore senza aiuti. Caratteristiche principali Tante immagini da ricomporre, divise per categorie Livelli di difficoltà da 3x3 pezzi a 8x8 pezzi Modalità hardcore per chi vuole emergere senza suggerimenti Salva le tue partite e riprendi dove avevi lasciato Classifica per vedere i tuoi migliori risultati Suoni e musica di sottofondo Puoi cambiare lingua tra italiano e inglese Aggiungi immagini tue per creare puzzle personalizzati Opzioni per musica e suoni on/off Compatibile con mouse e touch screen Cosa serve per giocare Un computer con Windows Una risoluzione schermo di almeno 1024x768 pixel Memoria sufficiente per le immagini Il gioco usa il framework Love2D, quindi devi avere quello installato. Come installare Scarica i file del gioco da questo progetto. Installa Love2D dal sito ufficiale. Apri i file del gioco con Love2D oppure trascina la cartella principale su love.exe. Il gioco si avvia automaticamente. Crediti Immagini fornite da Pexels Musica sotto licenza Creative Commons da artisti come Scott Buckley, Keys of Moon, Purrple Cat e altri Sviluppato usando Love2D Font utilizzare: Caviar Dreams Tutti i crediti dettagliati sono nel file credits.txt. Licenza Le immagini e la musica sono fornite sotto licenze Creative Commons. Il codice del gioco è disponibile per uso personale."
  },
  {
    "title": "Play64 fantasy console",
    "url": "play64/index.html",
    "date": "2025-09-17",
    "content": "Play64 è una fantasy console sviluppata per The Tool Jam 2025. Ha un D-pad e due pulsanti azione, con uno schermo logico di default di 128x128 pixel (come Pico-8) e una palette di quattro sfumature di viola. I giochi (\"carts\") sono scritti in Lua 5.1. La console è realizzata in BlitzMax NG e Raylib. Controls The up button is mapped to the UP and W keys The down button is mapped to the DOWN and S keys The left button is mapped to the LEFT and A keys The right button is mapped to the RIGHT and D keys The A button is mapped to the Z and N keys The B button is mapped to the X and M keys Press ESC to close the application window Press R to reset the console Press F to toggle fullscreen mode Press P to pause the game How to release your game To prepare your game for release, edit the config.ini file: set Game to your game's internal name, Title to the window title, and Intro to False . Remove any unused files from the carts directory. You may then rename the play64.exe executable as desired. \"config.ini\" file [Settings] ; This is the configuration file for the Play64 fantasy console ; It contains settings for the console Fullscreen=False ; Set to True for fullscreen mode ; Set to False for windowed mode Width=800 ; Width of the window in pixels Height=600 ; Height of the window in pixels Intro=True ; Set to True to show the intro screen ; Set to False to skip the intro screen Game= ; The name of the game to load ; Leave empty to load the selection screen Title=Play64 fantasy console ; This is the title of the window ; It will be displayed in the title bar ; The title of the window can be changed in the code input The object module offer an interface to the input system input.down() Return a string with the key that is pressed print(input.down()) -- print up or down or left or right or a or b input.pressed() Return a string with the key that has been pressed print(input.pressed()) -- print up or down or left or right or a or b input.released() Return a string with the key that has been released print(input.released()) -- print up or down or left or right or a or b draw The object module offer an interface to the drawing commands colors palette La palette di Play64 ora è composta da 16 colori stile Pico-8. Puoi selezionare un colore tramite il suo indice (0-15) oppure tramite nome inglese (es: \"red\", \"blue\"). Indice Nome RGB 0 black 0, 0, 0 1 dark_blue 29, 43, 83 2 dark_purple 126, 37, 83 3 dark_green 0, 135, 81 4 brown 171, 82, 54 5 dark_gray 95, 87, 79 6 light_gray 194, 195, 199 7 white 255, 241, 232 8 red 255, 0, 77 9 orange 255, 163, 0 10 yellow 255, 236, 39 11 green 0, 228, 54 12 blue 41, 173, 255 13 lavender 131, 118, 156 14 pink 255, 119, 168 15 peach 255, 204, 170 Esempi d'uso: draw.color(&quot;red&quot;) draw.background(&quot;dark_blue&quot;) draw.color(10) -- giallo draw.background(color:Int) Change the color of background 0 = darkest, 3 = brightest draw.background(0) draw.color(color:Int) set the color of the draw command 0 = darkest, 3 = brightest draw.color(3) draw.point(x:Int, y:int ) Draw a pixel --draw a point draw.point(32,18) draw.line(startx:Int, startY:Int, endX:Int, endY:Int) Draw a line --draw a line draw.line(0,0,18,36) draw.rect(x:Int, y:Int, Width:Int, height:Int) Draw a rectangle --draw a rectangle draw.rect(0,0,20,20) draw.text(text:String, x:Int, y:Int, size:Int) Print a string of text Minimum size = 10 draw.text(&quot;a string of text&quot;,0,0,15) draw.circle(x:Int, y:Int, Radius:Int) Draw a circle --draw a circle draw.rect(30,30,10) draw.triangle(x1:Int, y1:Int, x2:Int, y2:Int, x3:Int, y3:Int) Draw a triangle --draw a triangle draw.triangle(1,1,63,1,32,63) draw.sprite(title:String, x:Int, y:Int) draw.sprite(&quot;enemy&quot;, 10,10) -- same as sprites.draw(&quot;enemy&quot;,10,10) app The object module offer an interface for manage all the app settings app.dt() Return the delta time in seconds The default game target fps is 30 frame per second. app.title(title:String) set the title of the window app.width(width:Int) set the width of the window app.height(heigth:Int) set the height of the window app.fullscreen() toggle the fullscreen mode app.reset() reset the cart and go back to selection screen app.restart() restart the current cart app.loadCart(cart:String) load a specific cart app.loadCart(&quot;snake&quot;) app.save(key:String, value:String) save a value of the current game app.save(&quot;highscore&quot;, &quot;1000&quot;) app.load(key:String, value:String) load a value of the current game app.load(&quot;highscore&quot;) Sound The object module offer an interface to sound system sound.play(sound:String) play a built-in sound by name --play bump sound effect sound.play(&quot;bump&quot;) Possible values: bottle_break, bump, cancel, cat_meow, click, confirm, crunch, digital_alarm, dog_bark, door_slow_open, drink, evil_laugh, explosion, gun, hurt, jump, laser_gun, low_health, menu_in, menu_out, monster_scream, notso_confirm, pause, phone_ring, powerdown, powerup, siren, steps, sword_slash, thunder, trampoline, water_splash, Camera The object module offer an interface to the camera system camera.target(x:Int, y:Int) --set position of the camera at 10, 10 camera.target(10,10) camera.offset(x:Int, y:Int) --set offset of the camera at 10, 10 camera.offset(10,10) camera.rotation(deg:Float) --set rotation of the camera at 45 camera.target(45.0) camera.zoom(zoom:Float) --set zoom of the camera at 1.2 camera.target(1.2) camera.reset() --reset the camera camera.reset() Sprites sprites.add(title:String, data:String) Return title:String local enemySprite = [[ 0 0 0 0 0 0 0 0 0 0 0 1 1 1 1 1 1 1 1 0 0 1 0 0 0 0 0 0 1 0 0 1 0 1 1 1 1 0 1 0 0 1 0 1 0 0 1 0 1 0 0 1 0 1 1 1 1 0 1 0 ]] sprite = sprites.add(&quot;enemy&quot;, enemySprite) -- sprite == &quot;enemy&quot; sprites.draw(title:String, x:Int, y:Int) sprites.draw(&quot;enemy&quot;,10,10) -- same as draw.sprite(&quot;enemy&quot;, 10,10) sprites.collision(sprite1:String, x1:Int, y1:Int, sprite2:String, x2:Int, y2:Int) Return 1 in case of collision if sprites.collision(&quot;player&quot;,player.x,player.y,&quot;enemy&quot;,enemy.x,enemy.Y) == 1 then --Collision! Do something end Timer The object module offer an interface for manage timers timer.delay(fn, delay) Calls the function fn after the given delay time has passed. Returns the associated event. -- Prints &quot;Hello world!&quot; after 2 seconds timer.delay(function() print(&quot;Hello world!&quot;) end, 2) timer.recur(fn, delay) Calls the function fn at an interval of delay . Returns the associated event. -- Prints timer!&quot; every half-second timer.recur(function() print( timer!&quot;) end, .5) Chaining events To avoid having to deeply nest several functions when creating chains of events, the :after() method can be called on an event returned by timer.delay() . You can keep using the :after() method to create complex timed sequences. -- Prints &quot;cat&quot;, &quot;dog&quot;, then &quot;owl&quot;, waiting 1 second between each print timer.delay(function() print(&quot;cat&quot;) end, 1) :after(function() print(&quot;dog&quot;) end, 1) :after(function() print(&quot;owl&quot;) end, 1) Stopping events An event can be stopped and removed at any point by calling its :stop() method. To do this the event must be assigned to a variable when it is created. -- Create a new event local t = timer.delay(function() print( timer!&quot;) end, 10) -- Remove the event before it has a chance to run t:stop() Groups timer provides the ability to create event groups; these are objects which can have events added to them, and which are in charge of updating and handling their contained events. A group is created by calling the timer.group()` function. local group = timer.group() Once a group is created it acts independently of the timer` object, and must be updated each frame using its own update method. group:update() To add a events to a group, the group's :delay() or :recur() methods should be used. group:delay(function() print(&quot;hello world&quot;) end, 4) A good example of where groups are useful is for games where you may have a set of events which effect objects in the game world and which you want to pause when the game is paused. A group's events can be paused by simply neglecting to call its update() method; when a group is destroyed its events are also destroyed. object The object module offer an interface for OOP programming Creating a new class Point = object:extend() function Point:new(x, y) self.x = x or 0 self.y = y or 0 end Creating a new object local p = Point(10, 20) Extending an existing class Rect = Point:extend() function Rect:new(x, y, width, height) Rect.super.new(self, x, y) self.width = width or 0 self.height = height or 0 end Checking an object's type local p = Point(10, 20) print(p:is(Object)) -- true print(p:is(Point)) -- true print(p:is(Rect)) -- false Using mixins PairPrinter = object:extend() function PairPrinter:printPairs() for k, v in pairs(self) do print(k, v) end end Point = object:extend() Point:implement(PairPrinter) function Point:new(x, y) self.x = x or 0 self.y = y or 0 end local p = Point() p:printPairs() Using static variables Point = object:extend() Point.scale = 2 function Point:new(x, y) self.x = x or 0 self.y = y or 0 end function Point:getScaled() return self.x * Point.scale, self.y * Point.scale end Creating a metamethod function Point:__tostring() return self.x .. &quot;, &quot; .. self.y end Tween The object module offer an interface for tweening Tween creation local t = tween.new(duration, subject, target, [easing]) Creates a new tween. duration means how much the change will take until it's finished. It must be a positive number. subject must be a table with at least one key-value. Its values will be gradually changed by the tween until they look like target . All the values must be numbers, or tables with numbers. target must be a table with at least the same keys as subject . Other keys will be ignored. easing can be either a function or a function name (see the easing section below). It's default value is 'linear' t is the object that must be used to perform the changes - see the \"Tween methods\" section below. This function only creates and returns the tween. It must be captured in a variable and updated via t:update(dt) in order for the changes to take place. Tween methods local complete = t:update() Gradually changes the contents of subject to that it looks more like target as time passes. t is a tween returned by tween.new complete is true if the tween has reached its limit (its internal clock is &gt;= duration ). It is false otherwise. When the tween is complete, the values in subject will be equal to target 's. The way they change over time will depend on the chosen easing function. local complete = t:set(clock) Moves a tween's internal clock to a particular moment. t is a tween returned by tween.new clock is a positive number or 0. It's the new value of the tween's internal clock. complete works like in t:update ; it's true if the tween has reached its end, and false otherwise. If clock is greater than t.duration , then the values in t.subject will be equal to t.target , and t.clock will be equal to t.duration . t:reset() Resets the internal clock of the tween back to 0, resetting subject . t is a tween returned by tween.new This method is equivalent to t:set(0) . Easing functions Easing functions are functions that express how slow/fast the interpolation happens in tween. The easing functions can be found in the table tween.easing . They can be divided into several families: linear is the default interpolation. It's the simplest easing function. quad , cubic , quart , quint , expo , sine and circle are all \"smooth\" curves that will make transitions look natural. The back family starts by moving the interpolation slightly \"backwards\" before moving it forward. The bounce family simulates the motion of an object bouncing. The elastic family simulates inertia in the easing, like an elastic gum. Each family (except linear ) has 4 variants: in starts slow, and accelerates at the end out starts fast, and decelerates at the end inOut starts and ends slow, but it's fast in the middle outIn starts and ends fast, but it's slow in the middle family in out inOut outIn Linear linear linear linear linear Quad inQuad outQuad inOutQuad outInQuad Cubic inCubic outCubic inOutCubic outInCubic Quart inQuart outQuart inOutQuart outInQuart Quint inQuint outQuint inOutQuint outInQuint Expo inExpo outExpo inOutExpo outInExpo Sine inSine outSine inOutSine outInSine Circ inCirc outCirc inOutCirc outInCirc Back inBack outBack inOutBack outInBack Bounce inBounce outBounce inOutBounce outInBounce Elastic inElastic outElastic inOutElastic outInElastic When you specify an easing function, you can either give the function name as a string. The following two are equivalent: local t1 = tween.new(10, subject, {x=10}, tween.easing.linear) local t2 = tween.new(10, subject, {x=10}, 'linear') But since 'linear' is the default, you can also do this: local t3 = tween.new(10, subject, {x=10}) Custom easing functions You are not limited to tween's easing functions; if you pass a function parameter in the easing, it will be used. The passed function will need to take 4 parameters: t (time): starts in 0 and usually moves towards duration b (begin): initial value of the of the property being eased. c (change): ending value of the property - starting value of the property d (duration): total duration of the tween And must return the new value after the interpolation occurs. local cubicbezier = function (x1, y1, x2, y2) local curve = love.math.newBezierCurve(0, 0, x1, y1, x2, y2, 1, 1) return function (t, b, c, d) return c * curve:evaluate(t/d) + b end end local label = { x=200, y=0, text = &quot;hello&quot; } local labelTween = tween.new(4, label, {y=300}, cubicbezier(.35, .97, .58, .61)) Credits Engine written in BlitzMax NG Carts written in Lua 5.1 The graphic library is Raylib Classic by rxi for lua OOP Tween by kikito Tick by rxi Sound Effects by Coffee 'Valen' Bat Name Size Date Download docs.pdf 137.8 KB 2025-05-14 13:19 Download play64.zip 1.7 MB 2025-05-14 13:22 Download"
  },
  {
    "title": "Screenshots",
    "url": "play64/_gallery/index.html",
    "date": "2025-09-17",
    "content": "× ‹ ›"
  },
  {
    "title": "Screenshots",
    "url": "jigsaw/_gallery/index.html",
    "date": "2025-09-17",
    "content": "× ‹ ›"
  },
  {
    "title": "screenshots",
    "url": "gssg/_gallery/index.html",
    "date": "2025-09-17",
    "content": "× ‹ ›"
  }
]